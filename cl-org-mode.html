<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>CL-ORG-MODE : A Parser of org-mode outlines</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2009-12-01 12:10:19 PST"/>
<meta name="author" content="Drew Crampsie"/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color:lightblue; font-weight:normal }
  .target { }
  .timestamp { color: grey }
  .timestamp-kwd { color: CadetBlue }
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*/-->
</script>
</head><body>
<h1 class="title">CL-ORG-MODE : A Parser of org-mode outlines</h1>

<p><i>abstract</i>: CL-ORG-MODE is a parser for org-mode files that uses an
extensible CLOS-based recursive descent parser to create a tree of
org-mode nodes. Also included is a (primitive) system for literate
programming using org-mode
</p>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Introduction </a>
<ul>
<li><a href="#sec-1.1">1.1 Features </a></li>
<li><a href="#sec-1.2">1.2 Planned Features </a></li>
</ul>
</li>
<li><a href="#sec-2">2 Finding and Installing </a></li>
<li><a href="#sec-3">3 CL-ORG-MODE Documentation </a>
<ul>
<li><a href="#sec-3.1">3.1 The Parser </a>
<ul>
<li><a href="#sec-3.1.1">3.1.1 Parser Concepts </a></li>
<li><a href="#sec-3.1.2">3.1.2 Parser Dictionary </a></li>
</ul>
</li>
<li><a href="#sec-3.2">3.2 Org Nodes </a>
<ul>
<li><a href="#sec-3.2.1">3.2.1 Org Node Concepts </a></li>
<li><a href="#sec-3.2.2">3.2.2 Org Node Dictionary </a></li>
</ul>
</li>
<li><a href="#sec-3.3">3.3 The Literate Programming System </a>
<ul>
<li><a href="#sec-3.3.1">3.3.1 Literate Programming Concepts </a></li>
<li><a href="#sec-3.3.2">3.3.2 Literate Programming Dictionary </a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-4">4 CL-ORG-MODE : The Source Code </a>
<ul>
<li><a href="#sec-4.1">4.1 The CL-ORG-MODE system definition </a></li>
<li><a href="#sec-4.2">4.2 CL-ORG-MODE Package </a></li>
<li><a href="#sec-4.3">4.3 The Parser Protocol </a></li>
<li><a href="#sec-4.4">4.4 The Parser </a></li>
<li><a href="#sec-4.5">4.5 An implementation of the protocol for org-mode files </a>
<ul>
<li><a href="#sec-4.5.1">4.5.1 The ORG-NODE base class + default text node </a></li>
<li><a href="#sec-4.5.2">4.5.2 ORG-PARENT-NODE : for nodes that have children, + ROOT-NODE. </a></li>
<li><a href="#sec-4.5.3">4.5.3 DELIMITED-NODE </a></li>
<li><a href="#sec-4.5.4">4.5.4 OUTLINE-NODE : Used for org-mode outlines </a></li>
<li><a href="#sec-4.5.5">4.5.5 SRC-NODE : Make blocks out of BEGIN<sub>SRC</sub> nodes. </a></li>
<li><a href="#sec-4.5.6">4.5.6 PROPERTIES-NODE: Capture the :PROPERTIES drawer </a></li>
</ul>
</li>
<li><a href="#sec-4.6">4.6 A printer for org-nodes </a></li>
<li><a href="#sec-4.7">4.7 Utilities </a></li>
</ul>
</li>
<li><a href="#sec-5">5 ORG-LITERATE-PROGRAMMING Source Code </a></li>
<li><a href="#sec-6">6 ORG-LISP-DOCUMENTATION </a>
<ul>
<li><a href="#sec-6.1">6.1 Doctstring parsing </a></li>
<li><a href="#sec-6.2">6.2 Print lisp documentation </a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">1 Introduction </h2>
<div id="text-1">


<p>
Org-mode is an emacs mode that provides, among other things, an
outliner and document authoring system. CL-ORG-MODE is a library for
manipulating org-mode files in Common Lisp.
</p>

</div>

<div id="outline-container-1.1" class="outline-3">
<h3 id="sec-1.1">1.1 Features </h3>
<div id="text-1.1">


<p>
CL-ORG-MODE is still in development, but is already being used to
develop itself. Some features:
</p>
<ul>
<li>
An extensible parser with a concrete implementation for a
subset of org-mode features.

</li>
<li>
A simple literate programming like system for writing Common
Lisp code inside org mode.

</li>
</ul>
</div>

</div>

<div id="outline-container-1.2" class="outline-3">
<h3 id="sec-1.2">1.2 Planned Features </h3>
<div id="text-1.2">


<ul>
<li>
Better integration with slime (the package issue).
</li>
<li>
Extensible printer to go with the parser. 
</li>
<li>
'round trip' from source files to org-mode nodes, so changes in
generated .lisp files end up in the .org.

</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">2 Finding and Installing </h2>
<div id="text-2">


<p>
This document, or possibly the document used to generate this
document, is a complete copy of the cl-org-mode source&hellip; it
just needs extracting, which requires cl-org-mode or some manual
labour. If the former idea is more to your liking, get it using
git :
</p>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">3 CL-ORG-MODE Documentation </h2>
<div id="text-3">



</div>

<div id="outline-container-3.1" class="outline-3">
<h3 id="sec-3.1">3.1 The Parser </h3>
<div id="text-3.1">


</div>

<div id="outline-container-3.1.1" class="outline-4">
<h4 id="sec-3.1.1">3.1.1 Parser Concepts </h4>
<div id="text-3.1.1">


<p>
Right now the parser is very simple. The function READ-ORG-FILE
will read an org-mode file into a tree of ORG-NODEs.
</p>
</div>

</div>

<div id="outline-container-3.1.2" class="outline-4">
<h4 id="sec-3.1.2">3.1.2 Parser Dictionary </h4>
<div id="text-3.1.2">

<ul>
<li id="sec-3.1.2.1"><i>Function</i> <code>READ-ORG-FILE</code> <br/>

<p>
<i>Function</i> <code>READ-ORG-FILE</code>
</p>
<p>
<b>Syntax:</b>
</p>
<p>
<code>read-org-file</code> pathname =&gt; <i>result</i>
</p>
<p>
<b>Description:</b>
</p>
<p>
Read the org file located at PATHNAME and return an ORG-FILE node.
</p></li>
</ul>
</div>
</div>

</div>

<div id="outline-container-3.2" class="outline-3">
<h3 id="sec-3.2">3.2 Org Nodes </h3>
<div id="text-3.2">


</div>

<div id="outline-container-3.2.1" class="outline-4">
<h4 id="sec-3.2.1">3.2.1 Org Node Concepts </h4>
<div id="text-3.2.1">

</div>

</div>

<div id="outline-container-3.2.2" class="outline-4">
<h4 id="sec-3.2.2">3.2.2 Org Node Dictionary </h4>
<div id="text-3.2.2">

</div>
</div>

</div>

<div id="outline-container-3.3" class="outline-3">
<h3 id="sec-3.3">3.3 The Literate Programming System </h3>
<div id="text-3.3">


</div>

<div id="outline-container-3.3.1" class="outline-4">
<h4 id="sec-3.3.1">3.3.1 Literate Programming Concepts </h4>
<div id="text-3.3.1">


<p>
The literate programming system is very simple at the
moment. Essentially, we recurse through the org-mode nodes. If a 
node sets the :source-file: property (<code>C-c C-x p source-file RET     filename.lisp RET</code>), any SOURCE-NODE has its contents inserted in
that file, in the order they appear.
</p>
<p>
The :source-directory: sets the directory in which the files will
be generated. Relative pathnames will be resolved relative to the
location of the org-mode file itself.
</p>
</div>

</div>

<div id="outline-container-3.3.2" class="outline-4">
<h4 id="sec-3.3.2">3.3.2 Literate Programming Dictionary </h4>
<div id="text-3.3.2">

<ul>
<li id="sec-3.3.2.1"><i>Function</i> <code>TANGLE-ORG-NODE</code> <br/>

<p>
<i>Function</i> <code>TANGLE-ORG-NODE</code>
</p>
<p>
<b>Syntax:</b>
</p>
<p>
<code>tangle-org-node</code> node <i>&amp;key</i> source-directory source-file =&gt; <i>result</i>
</p>
<p>
<b>Arguments and Values:</b>
</p>
<p>
node&mdash;an ORG-NODE
source-directory&mdash;a pathname,
source-file&mdash;a pathname.
result&mdash;returns NIL. 
</p>
<p>
<b>Description:</b>
</p>
<p>
Walk node and all its children, and print the contents of
any SRC-NODE to source-file. If source-file is a relative pathname, it
will be merged with source-directory.
</p>
<p>
If node or any of its children contain :source-file:
or :source-directory: properties, they will replace the value of
source-file or source-directory for that node and its children.
NIL
</p>



</li>
</ul>
</div>
</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">4 CL-ORG-MODE : The Source Code </h2>
<div id="text-4">


</div>

<div id="outline-container-4.1" class="outline-3">
<h3 id="sec-4.1">4.1 The CL-ORG-MODE system definition </h3>
<div id="text-4.1">




<pre class="src src-lisp">
<span style="color: #b22222;">;;; </span><span style="color: #b22222;">-*- lisp -*-
</span>
(defsystem <span style="color: #da70d6;">:cl-org-mode</span>
  <span style="color: #da70d6;">:components</span> 
  ((<span style="color: #da70d6;">:module</span> <span style="color: #da70d6;">:src</span>
            <span style="color: #da70d6;">:serial</span> t
            <span style="color: #da70d6;">:components</span>
            ((<span style="color: #da70d6;">:file</span> <span style="color: #bc8f8f;">"packages"</span>)
             (<span style="color: #da70d6;">:file</span> <span style="color: #bc8f8f;">"utils"</span>)
             (<span style="color: #da70d6;">:file</span> <span style="color: #bc8f8f;">"protocol"</span>)
             (<span style="color: #da70d6;">:file</span> <span style="color: #bc8f8f;">"parser"</span>)
             (<span style="color: #da70d6;">:file</span> <span style="color: #bc8f8f;">"cl-org-mode"</span>)
             )))
  <span style="color: #da70d6;">:serial</span> t
  <span style="color: #da70d6;">:depends-on</span> (<span style="color: #da70d6;">:alexandria</span> <span style="color: #da70d6;">:closer-mop</span>))

</pre>



</div>

</div>

<div id="outline-container-4.2" class="outline-3">
<h3 id="sec-4.2">4.2 CL-ORG-MODE Package </h3>
<div id="text-4.2">







<pre class="src src-lisp">
(<span style="color: #a020f0;">defpackage</span> <span style="color: #228b22;">:cl-org-mode</span> 
  (<span style="color: #da70d6;">:use</span> <span style="color: #da70d6;">:common-lisp</span>))
</pre>




</div>

</div>

<div id="outline-container-4.3" class="outline-3">
<h3 id="sec-4.3">4.3 The Parser Protocol </h3>
<div id="text-4.3">





<pre class="src src-lisp">
(<span style="color: #a020f0;">in-package</span> <span style="color: #da70d6;">:cl-org-mode</span>)

(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">node</span> ()
  ((next-node <span style="color: #da70d6;">:initarg</span> <span style="color: #da70d6;">:next-node</span> 
              <span style="color: #da70d6;">:accessor</span> node.next-node 
              <span style="color: #da70d6;">:initform</span> nil))
  (<span style="color: #da70d6;">:documentation</span> <span style="color: #bc8f8f;">"Base class for all nodes"</span>))

(<span style="color: #a020f0;">defvar</span> <span style="color: #b8860b;">*dispatchers*</span> nil
  <span style="color: #bc8f8f;">"A dynamic variable to hold a list of nodes to use as  dispatchers.
The default method for FIND-NEXT-NODE will call NODE-START on these nodes"</span>)

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">node-dispatchers</span> (node)
  (<span style="color: #da70d6;">:documentation</span> <span style="color: #bc8f8f;">"Called by the reader in order to set the dynamic dispatch environment before reading the next node"</span>))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">find-next-node</span> (node next-node stack)
  (<span style="color: #da70d6;">:documentation</span> <span style="color: #bc8f8f;">"Find the next node that starts in STREAM, implicitly ending NODE.

All methods must return the multiple values (VALUES NEW-NODE OLD-STACK) as if from NODE-START. "</span>))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">read-next-node</span> (node next-node stream)
  (<span style="color: #da70d6;">:documentation</span> <span style="color: #bc8f8f;">"read the next node in stream and return it.

This is the main entry point for specializing node types."</span>))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">read-node</span> (starting-node stream)
  (<span style="color: #da70d6;">:documentation</span> <span style="color: #bc8f8f;">"return the next node after reading it from the stream 

The default method simply calls READ-NEXT-NODE."</span>)
  (<span style="color: #da70d6;">:method</span> (starting-node stream)
    (read-next-node starting-node (node.next-node starting-node) stream)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">node-start</span> (node stack)
  (<span style="color: #da70d6;">:documentation</span> 
  <span style="color: #bc8f8f;">"Indicate a new node should begin at this point in the stack. 

The parser will pass a class prototype instance via NODE, so it
shouldn't be mutated.

All methods _must_ return (VALUES NEW-NODE OLD-STACK) where NEW-NODE
created NODE object and any remaining stack which likely belongs to
the previous node."</span>))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">node-end</span> (node next-node stack)
  (<span style="color: #da70d6;">:documentation</span> 
  <span style="color: #bc8f8f;">"return true if stack of characters indicate this node has finished reading"</span>))


(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">finalize-node</span> (node next-node stack)
  (<span style="color: #da70d6;">:documentation</span> <span style="color: #bc8f8f;">"Called when the node has finished reading.
 
This is usually either because node-end returned true or implicitly
because another node has started"</span>))
</pre>




</div>

</div>

<div id="outline-container-4.4" class="outline-3">
<h3 id="sec-4.4">4.4 The Parser </h3>
<div id="text-4.4">





<pre class="src src-lisp">
(<span style="color: #a020f0;">in-package</span> <span style="color: #da70d6;">:cl-org-mode</span>)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">read-next-node</span> (node (next-node null) stream) 
  <span style="color: #bc8f8f;">"This method is called when we don't yet know what the next node is"</span>
  (<span style="color: #a020f0;">let</span> (stack)
    (<span style="color: #a020f0;">loop</span> for char = (read-char stream nil)
       <span style="color: #da70d6;">:if</span> (null char) 
       <span style="color: #da70d6;">:do</span> (<span style="color: #a020f0;">return</span> (finalize-node node NIL stack))
       <span style="color: #da70d6;">:else</span> 
       <span style="color: #da70d6;">:do</span> (push char stack)
         (<span style="color: #a020f0;">multiple-value-bind</span> (new-node old-stack)
                 (find-next-node node next-node stack)     
               (<span style="color: #a020f0;">when</span> new-node 
                 (<span style="color: #a020f0;">return</span> (finalize-node node new-node old-stack)))))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">read-next-node</span> (node (next-node node) stream)
  <span style="color: #bc8f8f;">"When we know what the node is already, just return it"</span>
  next-node)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">read-next-node</span> <span style="color: #da70d6;">:around</span> (node next-node stream)
  (<span style="color: #a020f0;">let</span> ((*dispatchers* (node-dispatchers node)))
  <span style="color: #b22222;">;</span><span style="color: #b22222;">(warn "DISPATHERS FOR ~A ~A: ~A" node next-node *dispatchers*)
</span>    (call-next-method)))


(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">find-next-node</span> (node next-node stack)
  (<span style="color: #a020f0;">loop</span> for object in *dispatchers*
       <span style="color: #da70d6;">:do</span> (<span style="color: #a020f0;">multiple-value-bind</span> (result old-stack)
               (node-start object stack)
             (<span style="color: #a020f0;">when</span> result (<span style="color: #a020f0;">return</span> (values result old-stack))))))
</pre>




</div>

</div>

<div id="outline-container-4.5" class="outline-3">
<h3 id="sec-4.5">4.5 An implementation of the protocol for org-mode files </h3>
<div id="text-4.5">



</div>

<div id="outline-container-4.5.1" class="outline-4">
<h4 id="sec-4.5.1">4.5.1 The ORG-NODE base class + default text node </h4>
<div id="text-4.5.1">




<pre class="src src-lisp">
(<span style="color: #a020f0;">in-package</span> <span style="color: #da70d6;">:cl-org-mode</span>)

(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">org-node</span> (node) ())

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">node-start</span> ((node org-node) stream) nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">node-end</span> ((node org-node) next-node stream) nil)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">node-end</span> ((node org-node) (next-node null) stack)
  T)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">node-dispatchers</span> ((node org-node))
  (or *dispatchers* 
      (mapcar #'make-instance '(src-node properties-node outline-node))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">node-prototypes</span> (node)
  (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #bc8f8f;">"never call"</span>))


(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">finalize-node</span> (node next-node stack)
  <span style="color: #bc8f8f;">"If there is something on the stack, and a new node has started,
then stick it in the default node"</span>
<span style="color: #b22222;">;  </span><span style="color: #b22222;">(break "Finalizing ~A ~A ~A ~A" node next-node stack (node.next-node node))
</span>  (setf (node.next-node node) 
        (<span style="color: #a020f0;">if</span> stack
            (make-default-node node next-node stack)
          next-node)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">make-default-node</span> (node next-node stack)
  (<span style="color: #da70d6;">:documentation</span> <span style="color: #bc8f8f;">"Anything not in another node ends up here"</span>)
  (<span style="color: #da70d6;">:method</span> ((node org-node) next-node stack)
<span style="color: #b22222;">;  </span><span style="color: #b22222;">(break "Making default: ~A ~A ~A" node next-node stack)
</span>           (make-instance 'text-node 
                          <span style="color: #da70d6;">:text</span> (stack-&gt;string stack)
                          <span style="color: #da70d6;">:next-node</span> next-node)))

(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">text-node</span> (org-node)
  ((text <span style="color: #da70d6;">:initarg</span> <span style="color: #da70d6;">:text</span> <span style="color: #da70d6;">:accessor</span> node.text)))
</pre>




</div>

</div>

<div id="outline-container-4.5.2" class="outline-4">
<h4 id="sec-4.5.2">4.5.2 ORG-PARENT-NODE : for nodes that have children, + ROOT-NODE. </h4>
<div id="text-4.5.2">




<pre class="src src-lisp">
(<span style="color: #a020f0;">in-package</span> <span style="color: #da70d6;">:cl-org-mode</span>)

(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">org-parent-node</span> (org-node)
  ((child-nodes <span style="color: #da70d6;">:initarg</span> <span style="color: #da70d6;">:children</span> 
                <span style="color: #da70d6;">:accessor</span> node.children
                <span style="color: #da70d6;">:initform</span> nil)
   (include-end-node <span style="color: #da70d6;">:initarg</span> <span style="color: #da70d6;">:include-end-node</span>
                     <span style="color: #da70d6;">:initform</span> nil
                     <span style="color: #da70d6;">:reader</span> include-end-node-p))
  (<span style="color: #da70d6;">:documentation</span> <span style="color: #bc8f8f;">"Some node contain other nodes"</span>))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">read-child-nodes</span> (root-node stack stream )
  (<span style="color: #a020f0;">loop</span> 
     <span style="color: #da70d6;">:for</span> next-node = (read-node root-node stream) 
     <span style="color: #da70d6;">:then</span> (and next-node (read-node next-node stream))
     <span style="color: #da70d6;">:until</span> (node-end root-node next-node stack)
     <span style="color: #b22222;">;</span><span style="color: #b22222;">:do (warn "reading root ~A : next-node : ~A ~A" root-node next-node stack)
</span>     <span style="color: #da70d6;">:collect</span> next-node into nodes
     <span style="color: #da70d6;">:finally</span> (<span style="color: #a020f0;">return</span> (<span style="color: #a020f0;">if</span> (include-end-node-p root-node)
                          (values (nconc nodes (list next-node)) 
                                  next-node) 
                          (values  nodes next-node)))))
  

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">read-next-node</span> ((node org-parent-node)  (next-node null) stream)
  (call-next-method)

  (<span style="color: #a020f0;">multiple-value-bind</span> (children new-node) 
      (read-child-nodes node nil stream)
    (<span style="color: #a020f0;">when</span> children 
      (<span style="color: #a020f0;">unless</span> (eql (car children) (node.next-node node))
        <span style="color: #b22222;">;;; </span><span style="color: #b22222;">Somebody short-circuited the process, namely property-node. why?
</span>        (setf children (cons (node.next-node node) children))
        ))

    (setf (node.children node) children)
    new-node))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">read-node</span> <span style="color: #da70d6;">:around</span> ((node org-parent-node) stream)
 (<span style="color: #a020f0;">let</span> ((new-node (call-next-method)))
   (<span style="color: #a020f0;">if</span> (include-end-node-p node)
       (read-node new-node stream)
     new-node)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">read-parent-node</span> (parent-node stream)
  (read-node parent-node stream) parent-node) 
    
(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">org-file</span> (org-parent-node) 
  ((pathname <span style="color: #da70d6;">:accessor</span> node.pathname <span style="color: #da70d6;">:initarg</span> <span style="color: #da70d6;">:pathname</span>)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">read-org-file</span> (pathname)
  (<span style="color: #a020f0;">let</span> ((node (make-instance 'org-file <span style="color: #da70d6;">:pathname</span> pathname)))
    (<span style="color: #a020f0;">alexandria:with-input-from-file</span> (stream pathname) 
      (read-parent-node node stream))))
</pre>



</div>

</div>

<div id="outline-container-4.5.3" class="outline-4">
<h4 id="sec-4.5.3">4.5.3 DELIMITED-NODE </h4>
<div id="text-4.5.3">





<pre class="src src-lisp">
(<span style="color: #a020f0;">in-package</span> <span style="color: #da70d6;">:cl-org-mode</span>)

(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">delimited-node</span> (org-parent-node)
  ((opening-delimiter <span style="color: #da70d6;">:initarg</span> <span style="color: #da70d6;">:opening-delimiter</span> <span style="color: #da70d6;">:accessor</span> node.opening-delimiter <span style="color: #da70d6;">:initform</span> nil)
   (closing-delimiter <span style="color: #da70d6;">:initarg</span> <span style="color: #da70d6;">:closing-delimiter</span> <span style="color: #da70d6;">:accessor</span> node.closing-delimiter <span style="color: #da70d6;">:initform</span> nil)
   (closing-delimiter-node <span style="color: #da70d6;">:accessor</span> node.closing-delimiter-node)
   (node-closed <span style="color: #da70d6;">:initform</span> nil <span style="color: #da70d6;">:accessor</span> node.closed-p))

  (<span style="color: #da70d6;">:default-initargs</span> <span style="color: #da70d6;">:include-end-node</span> t))

(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">closing-delimiter-node</span> (org-node)
 ((opening-delimiter-node <span style="color: #da70d6;">:accessor</span> node.opening-delimiter-node <span style="color: #da70d6;">:initarg</span> <span style="color: #da70d6;">:opening-delimiter-node</span>)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">shared-initialize</span> <span style="color: #da70d6;">:after</span> ((node delimited-node) slots <span style="color: #228b22;">&amp;rest</span> args)
  (<span style="color: #a020f0;">declare</span> (ignore args))
  (setf (node.closing-delimiter-node node)
        (make-instance 'closing-delimiter-node <span style="color: #da70d6;">:opening-delimiter-node</span> node)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">node-dispatchers</span> ((node delimited-node))
  (<span style="color: #a020f0;">if</span> (node.closed-p node)
      (call-next-method)
      (cons (node.closing-delimiter-node node) (call-next-method))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">node-start</span> ((node delimited-node) stack)
  (<span style="color: #a020f0;">with-slots</span> (opening-delimiter) node
    (<span style="color: #a020f0;">when</span> opening-delimiter 
      (<span style="color: #a020f0;">multiple-value-bind</span> (delimiter old-stack)
          (stack-starts-with stack opening-delimiter)
        
        (<span style="color: #a020f0;">when</span> delimiter
          (values (make-instance (class-of node) 
                                 <span style="color: #da70d6;">:opening-delimiter</span> (stack-&gt;string delimiter)) 
                   old-stack))))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">node-start</span> ((node closing-delimiter-node) stack)

  (<span style="color: #a020f0;">with-slots</span> (closing-delimiter) (node.opening-delimiter-node node)
    (<span style="color: #a020f0;">multiple-value-bind</span> (indicator old-stack)
        (stack-starts-with stack closing-delimiter)
      (<span style="color: #a020f0;">when</span> indicator 
        (values node 
                old-stack)))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">node-end</span> ((node delimited-node) (next-node closing-delimiter-node) stack)
  (<span style="color: #a020f0;">when</span> (eq next-node (node.closing-delimiter-node node))
    (setf (node.closed-p node) t)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">read-next-node</span> <span style="color: #da70d6;">:around</span> ((node delimited-node) next-node stream)
  (call-next-method)
)
</pre>




</div>

</div>

<div id="outline-container-4.5.4" class="outline-4">
<h4 id="sec-4.5.4">4.5.4 OUTLINE-NODE : Used for org-mode outlines </h4>
<div id="text-4.5.4">






<pre class="src src-lisp">
(<span style="color: #a020f0;">in-package</span> <span style="color: #da70d6;">:cl-org-mode</span>)

(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">outline-node</span> (org-parent-node) 
  ((heading <span style="color: #da70d6;">:accessor</span> node.heading <span style="color: #da70d6;">:initform</span> nil <span style="color: #da70d6;">:initarg</span> <span style="color: #da70d6;">:heading</span>)
   (heading-level-indicator <span style="color: #da70d6;">:accessor</span> node.heading-level-indicator
                            <span style="color: #da70d6;">:initform</span> nil
                            <span style="color: #da70d6;">:initarg</span> <span style="color: #da70d6;">:indicator</span>)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">at-outline-node-p</span> (stack)
  (<span style="color: #a020f0;">let</span> ((char (first stack))
        (stack (rest stack)))
    (and (eql char #\space)
         (eql (first stack) #\*)
         (<span style="color: #a020f0;">if</span> (or (null (rest stack))
                 (eql #\Newline (second stack)))
             (values t  (rest stack))
             (at-outline-node-p (cons char (rest stack)))))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">node-start</span> ((node outline-node) stack)
  (<span style="color: #a020f0;">multiple-value-bind</span> (pred old-stack) 
      (at-outline-node-p stack)
    (<span style="color: #a020f0;">if</span> pred 
        (values  
           (make-instance (class-of node) 
                          <span style="color: #da70d6;">:indicator</span>
                          (<span style="color: #a020f0;">loop</span> 
                             for cons on stack 
                             until (eq cons old-stack) 
                             collect (car cons))) 
           old-stack))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">node-end</span> ((node outline-node) (next-node outline-node) stack)   
  (&lt;= (length (node.heading-level-indicator next-node))
      (length (node.heading-level-indicator node))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">node-end</span> ((node outline-node) (next-node null) stack)   
  t)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">read-next-node</span> ((node outline-node) (next-node null) stream)
  (setf (node.heading node) (read-line stream nil))
  (call-next-method))
</pre>




</div>

</div>

<div id="outline-container-4.5.5" class="outline-4">
<h4 id="sec-4.5.5">4.5.5 SRC-NODE : Make blocks out of BEGIN<sub>SRC</sub> nodes. </h4>
<div id="text-4.5.5">




<pre class="src src-lisp">
(<span style="color: #a020f0;">in-package</span> <span style="color: #da70d6;">:cl-org-mode</span>)

(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">src-node</span> (delimited-node text-node)
  ((emacs-mode <span style="color: #da70d6;">:initarg</span> <span style="color: #da70d6;">:emacs-mode</span> <span style="color: #da70d6;">:accessor</span> node.emacs-mode <span style="color: #da70d6;">:initform</span> nil))
  (<span style="color: #da70d6;">:default-initargs</span> 
    <span style="color: #da70d6;">:opening-delimiter</span> <span style="color: #bc8f8f;">"#+BEGIN_SRC"</span>
    <span style="color: #da70d6;">:closing-delimiter</span> (format nil <span style="color: #bc8f8f;">"~%#+END_SRC"</span>)
    <span style="color: #da70d6;">:text</span> nil
    <span style="color: #da70d6;">:include-end-node</span> nil))


(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">node-dispatchers</span> ((node src-node))
  (<span style="color: #a020f0;">if</span> (node.text node)
      (call-next-method)
      (list (node.closing-delimiter-node node))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">read-next-node</span> ((node src-node) (next-node null) stream)
  (setf (node.emacs-mode node) (read-line stream nil))
  (call-next-method))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">finalize-node</span> ((node src-node) next-node stack)
  (setf (node.next-node node) next-node)
   (setf (node.text node) (stack-&gt;string stack))
  next-node)
</pre>



</div>

</div>

<div id="outline-container-4.5.6" class="outline-4">
<h4 id="sec-4.5.6">4.5.6 PROPERTIES-NODE: Capture the :PROPERTIES drawer </h4>
<div id="text-4.5.6">




<pre class="src src-lisp">
(<span style="color: #a020f0;">in-package</span> <span style="color: #da70d6;">:cl-org-mode</span>)

(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">properties-node</span> (delimited-node)
  ()

  (<span style="color: #da70d6;">:default-initargs</span> 
    <span style="color: #da70d6;">:opening-delimiter</span> <span style="color: #bc8f8f;">":PROPERTIES:
"</span>
    <span style="color: #da70d6;">:closing-delimiter</span> <span style="color: #bc8f8f;">":END:"</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">finalize-node</span> ((node properties-node) next-node stack)
  (call-next-method))

(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">property-node</span> (delimited-node)
  ((property <span style="color: #da70d6;">:initarg</span> <span style="color: #da70d6;">:property</span> <span style="color: #da70d6;">:accessor</span> property-node.property)
   (value <span style="color: #da70d6;">:initarg</span> <span style="color: #da70d6;">:value</span> <span style="color: #da70d6;">:accessor</span> property-node.value))  
  (<span style="color: #da70d6;">:default-initargs</span> 
    <span style="color: #da70d6;">:closing-delimiter</span> (format nil <span style="color: #bc8f8f;">"~%"</span>)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">node-start</span> ((node property-node) stack)
  (<span style="color: #a020f0;">let</span> ((pos (position #\: (cdr stack))))
    (<span style="color: #a020f0;">when</span> (and pos (eql #\: (car stack)))

      (<span style="color: #a020f0;">let</span> ((property (nreverse (coerce (subseq (cdr stack) 0 pos) 'string ))))
        (<span style="color: #a020f0;">when</span> property
          (values (make-instance (class-of node)
                                 <span style="color: #da70d6;">:property</span> property)
                  (subseq (cddr stack) pos)))))))


(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">finalize-node</span> ((node property-node) next-node stack)
  (setf (property-node.value node) (nreverse (coerce (butlast stack) 'string)))
  (call-next-method node next-node (cons (first stack ) (last stack))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">node-dispatchers</span> ((node properties-node))
  (<span style="color: #a020f0;">let</span> ((dispatchers (call-next-method)))
    (list (node.closing-delimiter-node node)
           (make-instance 'property-node)
           )))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-property-value</span> (node key)
  (<span style="color: #a020f0;">let</span> ((node (find-if 
               (<span style="color: #a020f0;">lambda</span> (n)
                 (and (typep n 'property-node)
                      (equal (property-node.property n) key)))
               (node.children node))))
    (<span style="color: #a020f0;">when</span> node (property-node.value node))))
</pre>



<p>
**
</p></div>
</div>

</div>

<div id="outline-container-4.6" class="outline-3">
<h3 id="sec-4.6">4.6 A printer for org-nodes </h3>
<div id="text-4.6">




<pre class="src src-lisp">
(<span style="color: #a020f0;">in-package</span> <span style="color: #da70d6;">:cl-org-mode</span>)

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">print-node</span> (node <span style="color: #228b22;">&amp;optional</span> stream)
  (<span style="color: #da70d6;">:documentation</span> <span style="color: #bc8f8f;">"Print text serialization of node."</span>)
  (<span style="color: #da70d6;">:method</span> <span style="color: #da70d6;">:around</span> (node <span style="color: #228b22;">&amp;optional</span> (stream *standard-output*))
           (call-next-method node stream)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-node</span> <span style="color: #da70d6;">:around</span> ((node delimited-node) <span style="color: #228b22;">&amp;optional</span> stream)
  (write-sequence (node.opening-delimiter node) stream)
  (call-next-method))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-node</span> ((node closing-delimiter-node) <span style="color: #228b22;">&amp;optional</span> stream)
  (princ (node.closing-delimiter (node.opening-delimiter-node node)) stream))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-node</span> <span style="color: #da70d6;">:around</span> ((node outline-node) <span style="color: #228b22;">&amp;optional</span> stream)
  (format stream <span style="color: #bc8f8f;">"~A~A~%"</span> 
          (stack-&gt;string  (node.heading-level-indicator node))
          (node.heading node)) 
  (call-next-method))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-node</span> ((node property-node) <span style="color: #228b22;">&amp;optional</span> stream)
  (<span style="color: #a020f0;">with-slots</span> (property value) node
    (format stream <span style="color: #bc8f8f;">":~A: ~A~%"</span> property value)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-node</span>  ((node src-node) <span style="color: #228b22;">&amp;optional</span> stream)
  (format stream <span style="color: #bc8f8f;">"~A~%"</span>(node.emacs-mode node))
  (write-sequence (node.text node) stream))
</pre>




</div>

</div>

<div id="outline-container-4.7" class="outline-3">
<h3 id="sec-4.7">4.7 Utilities </h3>
<div id="text-4.7">

<ul>
<li>
Note taken on <span class="timestamp">2009-11-28 Sat 15:24</span>



<pre class="src src-lisp">
(<span style="color: #a020f0;">in-package</span> <span style="color: #da70d6;">:cl-org-mode</span>)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">stack-&gt;string</span> (stack)
  (nreverse (coerce stack 'string)))

(<span style="color: #a020f0;">defgeneric</span> <span style="color: #0000ff;">stack-starts-with</span> (stack maybe-starts-with)
  (<span style="color: #da70d6;">:documentation</span> 
   <span style="color: #bc8f8f;">"return (values start-of-stack rest-of-stack) if stack starts with maybe-starts-with.
If maybe-starts-with is a string. reverse it before testing against stack"</span>)
  (<span style="color: #da70d6;">:method</span> (stack list)
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">there are better ways to do this i'm sure.
</span>    (<span style="color: #a020f0;">let</span> ((does-it? (<span style="color: #a020f0;">when</span> (&gt;= (length stack)(length list))
                      (<span style="color: #a020f0;">loop</span> <span style="color: #da70d6;">:for</span> cons on stack 
                         <span style="color: #da70d6;">:for</span> pair on list
                         <span style="color: #da70d6;">:always</span> (eql (car cons) (first pair))))))
                      
      (<span style="color: #a020f0;">when</span> does-it? 
        (values list (nthcdr (length list) stack)))))
  
  (<span style="color: #da70d6;">:method</span> (stack (string string))
    (stack-starts-with stack (coerce (reverse string) 'list))))
</pre>




</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5">5 ORG-LITERATE-PROGRAMMING Source Code </h2>
<div id="text-5">




<pre class="src src-lisp">
(<span style="color: #a020f0;">in-package</span> <span style="color: #da70d6;">:cl-org-mode</span>)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">tangle-org-node</span> (node <span style="color: #228b22;">&amp;key</span> (source-directory (node.pathname node)) source-file)
  <span style="color: #bc8f8f;">"Arguments and Values:

node---an ORG-NODE
source-directory---a pathname,
source-file---a pathname.
result---returns NIL. 

Description:

Walk node and all its children, and print the contents of
any SRC-NODE to source-file. If source-file is a relative pathname, it
will be merged with source-directory.

If node or any of its children contain :source-file:
or :source-directory: properties, they will replace the value of
source-file or source-directory for that node and its children."</span>

  (<span style="color: #a020f0;">flet</span> ((tangle () (<span style="color: #a020f0;">loop</span> for child in (node.children node)
              <span style="color: #da70d6;">:do</span>  
              (<span style="color: #a020f0;">typecase</span> child 
                                (outline-node 
                 (<span style="color: #a020f0;">let</span> ((properties (find-if (<span style="color: #a020f0;">lambda</span> (x) (typep x 'properties-node))
                                            (node.children child))))

                   (<span style="color: #a020f0;">when</span> properties 
                     (setf source-directory 
                           (<span style="color: #a020f0;">let</span> ((path (get-property-value properties <span style="color: #bc8f8f;">"source-directory"</span>)))
                             (<span style="color: #a020f0;">if</span> path
                                 (<span style="color: #a020f0;">if</span> (eq <span style="color: #da70d6;">:RELATIVE</span> (first (pathname-directory path)))
                                     (merge-pathnames path source-directory)
                                     path)
                                 source-directory)))
                     (setf source-file (or (get-property-value properties <span style="color: #bc8f8f;">"source-file"</span>) source-file)))
                   (tangle-org-node child 
                                    <span style="color: #da70d6;">:source-directory</span> source-directory
                                    <span style="color: #da70d6;">:source-file</span> source-file
                                    )))
                (src-node
                 (<span style="color: #a020f0;">if</span> (streamp source-file)
                     (write-sequence (node.text child) source-file)
                     (<span style="color: #ff0000; font-weight: bold;">warn</span> <span style="color: #bc8f8f;">"Source node has no stream"</span>)))))))
         (<span style="color: #a020f0;">if</span> (and source-file
                  (not (streamp source-file)))
             (<span style="color: #a020f0;">alexandria:with-output-to-file</span> (stream (merge-pathnames source-file source-directory) 
                                                     <span style="color: #da70d6;">:if-exists</span> <span style="color: #da70d6;">:supersede</span> 
                                                     <span style="color: #da70d6;">:if-does-not-exist</span> <span style="color: #da70d6;">:create</span>)
               (setf source-file stream)
               (tangle))
             (tangle))))
</pre>




</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6">6 ORG-LISP-DOCUMENTATION </h2>
<div id="text-6">


</div>

<div id="outline-container-6.1" class="outline-3">
<h3 id="sec-6.1">6.1 Doctstring parsing </h3>
<div id="text-6.1">




<pre class="src src-lisp">
(<span style="color: #a020f0;">in-package</span> <span style="color: #da70d6;">:cl-org-mode</span>)

(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">lisp-docstring</span> (org-parent-node) ())

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">node-dispatchers</span> <span style="color: #da70d6;">:around</span> ((node lisp-docstring))
  (mapcar #'make-instance '(lisp-docstring-section-node)))

(<span style="color: #a020f0;">defclass</span> <span style="color: #228b22;">lisp-docstring-section-node</span> (lisp-docstring) 
  ((heading <span style="color: #da70d6;">:accessor</span> node.heading <span style="color: #da70d6;">:initform</span> nil <span style="color: #da70d6;">:initarg</span> <span style="color: #da70d6;">:heading</span>)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">section-node-start-p</span> (stack)
  (<span style="color: #a020f0;">when</span> (and (eql #\Newline (first stack))
             (eql #\Newline (second stack))
             (eql (third stack) #\:))
    (<span style="color: #a020f0;">break</span> <span style="color: #bc8f8f;">"~A second stack"</span> (char-name  (Second stack)))
    
    (<span style="color: #a020f0;">let</span> ((stack (cddr stack))) 
      (and (eql (first stack) #\:)
           (<span style="color: #a020f0;">loop</span> 
              <span style="color: #da70d6;">:for</span> (char . chars) on stack
              <span style="color: #da70d6;">:collect</span> char into heading
              <span style="color: #da70d6;">:if</span> (and (or (null chars)
                           (and (eql (first chars) #\Newline)
                                (eql (second chars) #\Newline)))
                       (alpha-char-p char))
              <span style="color: #da70d6;">:do</span> (<span style="color: #a020f0;">return</span> (values heading chars)))))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">node-start</span> ((node lisp-docstring-section-node) stack)
  (<span style="color: #a020f0;">multiple-value-bind</span> (heading old-stack) 
      (section-node-start-p stack)
    (<span style="color: #a020f0;">if</span> heading 
        (values  
         (make-instance (class-of node) <span style="color: #da70d6;">:heading</span> (stack-&gt;string heading)) 
           old-stack))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">node-end</span> ((node lisp-docstring-section-node) (next-node lisp-docstring-section-node) stack)   
  t)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">node-end</span> ((node lisp-docstring-section-node) (next-node null) stack)   
  t)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-node</span> ((node lisp-docstring-section-node) <span style="color: #228b22;">&amp;optional</span> stream)
  (format stream <span style="color: #bc8f8f;">"*~A*~%~%"</span>(node.heading node))
  (call-next-method))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">parse-docstring</span> (string)
  (<span style="color: #a020f0;">with-input-from-string</span> (stream string) 
    (read-parent-node (make-instance 'lisp-docstring) stream)))
</pre>




</div>

</div>

<div id="outline-container-6.2" class="outline-3">
<h3 id="sec-6.2">6.2 Print lisp documentation </h3>
<div id="text-6.2">




<pre class="src src-lisp">
(<span style="color: #a020f0;">in-package</span> <span style="color: #da70d6;">:cl-org-mode</span>)

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">print-docstring</span> (name type stream)
  (<span style="color: #a020f0;">let</span> ((docstring (parse-docstring (documentation name type))))
    (<span style="color: #a020f0;">if</span> (typep (first (node.children docstring)) 'lisp-docstring-section-node)
        (print-node docstring stream)
        (<span style="color: #a020f0;">progn</span> (format stream <span style="color: #bc8f8f;">"*Description:*~%"</span>)
               (print-node docstring stream)))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">print-doc-title</span> (object name stream)
  (format stream <span style="color: #bc8f8f;">"/~A/ "</span>   
          (split-sequence:split-sequence #\- (princ-to-string (type-of object))))
  (format stream <span style="color: #bc8f8f;">"=~a="</span>   
          name))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">newline-and-indent</span> (stream depth <span style="color: #228b22;">&amp;optional</span> (num 1)  (char #\Space) (newline #'terpri))
  (<span style="color: #a020f0;">dotimes</span> (n num) (funcall newline stream)
           (<span style="color: #a020f0;">dotimes</span> (n depth)
             (princ char stream))
           (princ #\Space stream)))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">cl-user::%t</span> (stream arg colon at <span style="color: #228b22;">&amp;rest</span> parameters)
  (<span style="color: #a020f0;">if</span> (listp arg)
      (<span style="color: #a020f0;">destructuring-bind</span> (depth char) arg
        (newline-and-indent stream depth (or (first parameters) 1) char (<span style="color: #a020f0;">if</span> colon #'fresh-line #'terpri)))
      (newline-and-indent stream arg (or (first parameters) 1))))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">convert-newline-to-indent</span> (string indent-level output-stream)
  (map nil (<span style="color: #a020f0;">lambda</span> (char) (<span style="color: #a020f0;">if</span> (eql char #\newline)
                              (format output-stream <span style="color: #bc8f8f;">"~/%t/"</span> indent-level)
                              (princ char output-stream)))
       string))
(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">print-lisp-documentation-to-org-node</span> (spec stream <span style="color: #228b22;">&amp;key</span> (starting-depth 2))
  (<span style="color: #a020f0;">flet</span> ((p ()
           (format stream <span style="color: #bc8f8f;">"~2/%t/"</span> starting-depth)) 
         (print-doc-title (object name)
           (format stream <span style="color: #bc8f8f;">"~:/%t/~@?~2/%t/~4:*~@?"</span>               
                   `(,starting-depth #\*)
                   <span style="color: #bc8f8f;">"/~:(~{~A~^ ~}~)/ =~A="</span>
                   (split-sequence:split-sequence  #\- (princ-to-string (type-of object)))
                   name
                   starting-depth))
         (print-function-syntax (name)
           (format stream <span style="color: #bc8f8f;">"*Syntax:*~2/%t/=~(~A~)= "</span> 
                   starting-depth 
                   name)
           (<span style="color: #a020f0;">dolist</span> (arg (swank::arglist name))
             (and (listp arg) (setf arg (car arg)))
             (format stream
                     (<span style="color: #a020f0;">if</span> (and (symbolp arg) 
                              (eql (aref (symbol-name arg) 0)
                                   #\&amp;))
                         <span style="color: #bc8f8f;">"/~(~A~)/ "</span>
                         <span style="color: #bc8f8f;">"~(~A~) "</span>) 
                     arg) )
           (format stream <span style="color: #bc8f8f;">"=&gt; /result/"</span>)))


    (<span style="color: #a020f0;">if</span> (listp spec)
        (<span style="color: #a020f0;">destructuring-bind</span> (type name) spec
          (<span style="color: #a020f0;">case</span> type
            (function 
             (<span style="color: #a020f0;">let</span> ((function (eval `#',name)))
               (print-doc-title function name)
               (p)
               (print-function-syntax name)
               (p)
               (convert-newline-to-indent 
                (<span style="color: #a020f0;">with-output-to-string</span> (s) (print-docstring name type s))
                starting-depth 
                stream))))
          ))))
</pre>







</div>
</div>
</div>
<div id="postamble"><p class="author"> Author: Drew Crampsie
<a href="mailto:Drew Crampsie <drewc@tech.coop>">&lt;Drew Crampsie <drewc@tech.coop>&gt;</a>
</p>
<p class="date"> Date: 2009-12-01 12:10:19 PST</p>
<p>HTML generated by org-mode 6.21b in emacs 23</p>
</div></body>
</html>
